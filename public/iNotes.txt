1.
import React, { useState, memo, useCallback } from "react";

export default function App() {
  const [input, setInput] = useState("");
  const [count, setCount] = useState(0);

  const incrementCount = useCallback(() => setCount(count + 1), [count]);
  return (
    <div>
      <input
        type="text"
        value={input}
        onChange={(e) => setInput(e.target.value)}
      />
      <button onClick={incrementCount}>Increment counter</button>
      <h3>Input text: {input}</h3>
      <h3>Count: {count}</h3>
      <hr />
      <ChildComponent count={count} onclick={incrementCount} />
    </div>
  );
}

// var props = {count: value, onclick: function}

const ChildComponent = memo(function ChildComponent({ count, onclick }) {
  console.log("child component is rendering");
  return (
    <div>
      <h2>This is a child component.</h2>
      <button onClick={onclick}>Increment</button>
      <h4>Count: {count}</h4>
    </div>
  );
});


:-

by using child component inside the memo(), the child component will not be rerendered on change of textbox value (not button click),
because button click changes the count value and count value is using in child component.its dependent on parent state.
on the change pf input the child component should not rerender.
just by doing small thing you save so many extra rerenders.

2. whenever you compare something ,you compare reference (not the internal values of that object).

3.useCallback:- in order to prevent parent component from creating a new reference of a function.useCallback reduces the cost of rerendering.


4.
